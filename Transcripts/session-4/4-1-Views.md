kịch bản video hướng dẫn từng bước — trình bày dạng video tutorial có thoại, từng bước rõ ràng, kết hợp phần hình ảnh minh họa , với nội dung sau: 
4-1-
Views
- [Narrator] The Revit API provides many different ways to create, edit, and populate elements with data, some of which we have explored so far on this course. Now let's have a look at different ways that we can display and annotate elements by automatically creating views, tagging elements, and creating sheets. There are several different types of view elements in the Revit API, all that inherit from the View class. These are the View3d, ViewDrafting, ViewPlan, ViewSection, and ViewSheet class. You might be able to guess that these classes are used to create 3D views, drafting, plan, section, and sheet views respectively. There are a couple different ways to differentiate views other than their class type. Views will also have a ViewType property which returns a type of enumeration. This describes the type of view that it is. For example, FloorPlan, Elevation, or Detail. Or we can differentiate by the view's view family type, which is the family type used to create the view. For example, this can be retrieved using the get type ID method from the view object. So in this video, let's create a simple command that allows us to automatically generate a view plan. Looking at the ViewPlan class in the object browser, we can see that we can create a view plan by accessing the static create method from the ViewPlan class. This takes the document, a viewFamilyTypeId, and a levelId for the parameters. It'll then return a ViewPlan object which we can use to access and edit the properties of a view. I've currently got the Visual Studio exercise file open for this video. In here I've created a PlanView class, which I've used to create an IExternalCommand. In this command, I've retrieved the document, which we can use in our method, I then retrieved a level, which is ground floor, which we can also use in our method, and then started a new transaction. This is where we can commit our view plan to the model. As we've got the document and the level, let's start by retrieving a view family type which we can use to create a view plan. One way of doing this is by filtering the document for all ViewFamily type classes, and then finding one with the ViewFamily property of FloorPlan. So let's try that by starting with a ViewFamily type variable named viewFamily. And then we'll assign to this a new FilteredElementCollector, which filters the document. We can find ViewFamily types by filtering by class, and we can do this by using the shortcut ofClass. Let's access this directly from the FilteredElementCollector we've just created. And for the parameter, we'll use a typeof ViewFamilyType. Next, let's cast the retrieved elements as ViewFamily types, so we can then access the properties. So, cast ViewFamilyType, and then open close parentheses. As we're often no specific ViewPlan type, let's just retrieve the first one that we can get from this collector. And to do that, let's proceed with the first method. Within the parameters of the first method, we can then write a lambda expression to filter all of the elements to find one with the ViewFamily property of FloorPlan. So let's add our parameter X, then lambda, and we want to check if the X ViewFamily is equal to ViewFamily FloorPlan. Great, so this will filter for the first ViewFamily type that has the property ViewFamily equal to FloorPlan. Next, I've already retrieved the level. We need the level ID to determine from which view the ViewPlan will be taken. So here I've just collected the ground floor. As we have all of the ingredients to create a ViewPlan, let's go ahead and do that between the start and commit methods within the transaction. So after the create view comment, let's create a ViewPlan variable named vPlan. And we'll assign to that a call to the create method from the ViewPlan class. For the parameters, let's use our document, our ViewFamily type, ID, and our level ID. Perfect, so there's our ViewPlan. To mark our new plan, let's rename it. Now we can do this by accessing the name property of a ViewPlan. So on the next line, let's access vPlan.Name, and let's assign to this: "Our first plan!" Perfect. I've already added this command into the manifest file. So let's go ahead and test it by hitting the debug button. And then opening up the Revit exercise file for this video, and then let's try our new command. From External Tools, and then PlanView. Perfect. It looks like our new plan has been created, which is based off the ground floor plan. Automatically creating plans from the API can be very useful for batch creating plans, for example.