kịch bản video hướng dẫn từng bước — trình bày dạng video tutorial có thoại, từng bước rõ ràng, kết hợp phần hình ảnh minh họa , với nội dung sau: 
4-4-
Sheets
- [Instructor] After annotating our views, the next natural step is to put them on to sheets. A Sheet in the Revit API is a type of view, which we can create using the ViewSheet class. This inherits from the View class. Like other View classes, the ViewSheet class, can be constructed by using the Create method within the class. This simply takes the document, and an element ID for the TitleBlock type. Here we could pass an invalid element ID, which would result in no TitleBlock being used. Once we have created a Sheet, we can place other views by creating viewports on the sheet, but we'll get to that in the next video. For now, lets create a new command that simply creates a new sheet. I currently have the Visual Studio exercise file open for this video. In here, I've created a Sheets class, which is a new IExternalCommand. I've gone ahead and retrieved the document, and started a new transaction. We can use this to create the sheets. So lets start by finding the TitleBlock we want to use. In the Revit exercise for this video, there's only one TitleBlock, which is the default template. So lets find this in our command by using the FilteredElementCollector, and retrieving the first we come across, which should be this one. If we had more in the project, we could find them by name, as we have done previously with other families. So to find the template, lets use a FilteredElementCollector, and retrieve the template as a FamilySymbol. Start by creating a FamilySymbol variable named tBlock, and then we'll assign to this a new FilteredElementCollector, filtering the document. Then to find TitleBlocks in the document, lets apply a ofCategory filter, filtering for the BuiltInCategory TitleBlocks. So, ofCategory, BuiltInCategory, OST_TitleBlocks. As we want a type, lets add in the WhereElementIsElementType filter, and then to retrieve it as a FamilySymbol, lets use the Cast method, which will cast to a FamilySymbol, and finally, to retrieve the first, lets simply use the First method. Great, so we now have the TitleBlock template we want. Lets go ahead and create a sheet within the Start and Commit methods of the transaction. To do that, lets create a ViewSheet variable named vSheet, and assign to this a call to the Create method from the ViewSheet class. For this method we need the document, which is doc, and then the ID of the TitleBlock we have retrieved, so tBlock.Id. Awesome, so we have created our first sheet. Before we try the command, lets change a couple of properties on the sheet, such as the name and sheet number. For the name, we can simply access the Name property, and assign a new string to it. I'm going to call mine, "My First Sheet". For the sheet number, we also need to use a string, and to do this, we access the SheetNumber property. I'm going to call mine "J101", perfect. So our command will now create a sheet, and automatically update the name and sheet number. I've already gone ahead and added this in to the manifest, so lets debug the command by hitting the Start button, and open up the Revit exercise file for this video. Then in our project file, lets go to the Add-Ins tab, External Tools, and run our command, which is Sheet. Then lets have a look in the Sheet section. Perfect, it looks like our sheet has been created, and the properties updated. We have successfully created a sheet with a template directly from the Revit API. This can be very handy when automating sheet creation. The next step is to start adding views.