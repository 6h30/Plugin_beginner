kịch bản video hướng dẫn từng bước — trình bày dạng video tutorial có thoại, từng bước rõ ràng, kết hợp phần hình ảnh minh họa , với nội dung sau: 
5-6-
Registering the event
Selecting transcript lines in this section will navigate to timestamp in the video
We now have our event handler method. Next, we need to register the event so that it executes on the event notification, that is when the document changes via a transaction. So let's start by registering the event in the OnStartup Method. To do this, let's wrap it in a Try Except Statement in case an exception occurs when the event is registered. So let's remove the exception that is currently in our OnStartup method and add a try and catch. If there is an exception, let's simply return the result as failed. Keep in mind here that the external DB application has its own result enumeration separate from the external application result. So let's access ExternalDBApplicationResult.Failed. Now, let's subscribe to the event inside of the try block. To do that, let's access the document changed event via the controlled application object that is passed to the method using the application variable. Then, we can add a delegate to the event by using the += symbol. The delegate is a type that will hold a reference to the event handler method that we created in the last video. It will allow us to pass our method as a parameter if it suits the required parameters for the event signature, that is the necessary object and DocumentChangedEventArgs parameters. Then when the event is raised, our method will be run. So let's add in a new event handler delegate and make sure to specify the event arguments in angle brackets. This will be DocumentChangedEventArgs which is used by the document changed event. Then, we can add our method to this by including the name inside of round brackets. So let's add in ElementChangedEvent. Now, whenever the document changed event occurs, our method will be called. After the try-catch statements, let's add in the result succeeded. Making sure that it's returned. Also, in the catch statement, making sure to return the failed result. So now that we've subscribed to the document changed event, we need to unsubscribe to the event after Revit shuts down so that it's not executed unintentionally. We can do that when Revit is shutting down, that is in the OnShutdown method. So inside of the OnShutdown method, let's remove the exception and we'll unsubscribe to the DocumentChangedEvent by accessing the application.DocumentChanged. And then instead of using +=, we use -=. Then, the event handler method to remove, in our case, it'll be ElementChangedEvent. Finally, let's simply return a successful result. So return ExternalDBApplicationResult.Succeeded. So we've now subscribed and unsubscribed to the document changed event through the Revit API. Anytime the document is changed through a transaction, our method will run which will filter the change elements to find furniture and if it finds one, it will relay that information to us. Before we hit debug, let's quickly check the manifest file to make sure that the class name matches that in the manifest. Down the bottom, we need to uncomment the DB application AddIn time. So remove these two tags. And then, let's change the full class name to ExternalDBApp. Great. Now, let's hit debug to try our new plugin and open up the Revit exercise file for this video. Then, let's try changing the document by moving a piece of furniture. So, let's click the move command. Awesome. So there's our task dialog showing us that the element ID 217813 was changed by the transaction name, Move. While this event may not be the most useful, you may realize how powerful this tool can be that has been able to subscribe to a large number of events that occur in Revit and automate all sorts of internal and external workflows.