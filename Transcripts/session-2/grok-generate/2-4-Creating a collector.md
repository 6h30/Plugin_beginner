kịch bản video hướng dẫn từng bước — trình bày dạng video tutorial có thoại, từng bước rõ ràng, kết hợp phần hình ảnh minh họa , với nội dung sau: 
2-4-
Creating a collector
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] With the fundamentals of filtered element collectors under our belt, let's go ahead and create our first one by filtering a Revit document of all elements that match the category of Windows. I've currently got the exercise file open for this video. In here I've gone ahead and created a CollectWindows IExternalCommand which is only retrieving the UIDocument and the Document. Let's use this command to filter the document for Windows. To start, let's simply create a new FilteredElementCollector by creating a FilteredElementCollector variable named collector. And we'll use this to filter the document, meaning it will search the entire document for elements. Next, we'll need to apply a filter to our collector, so let's have a look at some of the quick filters in the object browser. Search for elementQuickFilter. If we expand this class, you can see that we only have access to the base types, that is the classes that the elementQuickFilter inherits. We want to see the derived types. Currently this is out of the scope of our browser. We can fix this by creating a custom component set. Use the Browse dropdown menu and select Custom Component Set. Here we can add references externally to browse through them. Click the three dots to the side of the browser and browse to the Revit install folder. From within here, go ahead and select the RevitAPI, hold control and left click RevitAPIUI and add both of these assemblies. Then go ahead and click OK. Now when we search for elementQuickFilter, you can see that our browsing scope has increased and we can see the derived types. By expanding this, we can now view all of the quick filters deriving from the elementQuickFilter class each giving a summary of how it can be used. To collect Windows, let's use a simple element category filter. This provides four different ways to use the filter with an element ID for Window category or by using a built-in category. The constructors that take a Boolean simply invert the filter, so all categories that are not windows. As we learned in the last video, all built-in categories have an assigned built-in category enumeration. If we select this, you can see all the different options that are available in the built-in category enum. These relate to how they are in Revit. However, they're prefixed with OST. So, for example, Windows is simply OST_Windows. Let's use this method to create a filter in our command. To do that, let's create an elementQuickFilter variable named filter and we'll assign to this a new elementQuickFilter with the parameter of a builtInCategory of type OST_Windows. And you can see I've used elementQuickFilter which should be ElementCategoryFilter as the elementQuickFilter is the base class. Perfect. Now we can add this filter to our collector and retrieve the elements. To do that we can use the WherePasses method from the collector object. This allows us to apply filters using the filter as the parameter and now all the elements in the collector will be filtered for those that match the category of Window. Let's add another quick filter to speed the collector up faster by reducing the amount of elements it needs to search for. We can do that by using a shortcut method such as WhereElementIsNotElementType. This method can be accessed directly from the collector object and takes no parameters. This means it will filter out any element that isn't element type, so we're only after elements that are instances. Great, so now that we have applied the filters, we simply need to retrieve the elements by using the ToElements method which also takes no parameters. We need to store the collected windows and as we can see by hovering over the ToElements method, this returns an IList of type element, so let's add an IList variable named Windows to the front of our line to store the elements. Perfect. Now to check if we have the windows collected, let's add a TaskDialog to display the information. And we'll call it Windows. And we simply want to relay the number of windows we've collected. To do that, we can use the string.Format method. This will allow us to add an integer into a string. To do that, inside the string, we add an argument by using curly brackets, zero, close curly brackets and then the message we want to relay, so windows counted and then for the second parameter of the method, we add the integer we want to replace the zero with. In our case, it will be the count of members in the windows IList, so windwos.Count. And then our command will return the results exceeded. To register this command, let's simply go into our manifest file and copy and paste the last add-in. We can add multiple commands into the same add-in file. We just need to update a couple things. First off, the GUID. Let's go to Tools, Create GUID, copy this, and replace the current one. Next, we need to update the full class name. As we don't want to execute GetElementId, let's replace this with CollectWindows and the name of our command will be CollectWindows with an updated description. Perfect. Let's go ahead and try this command by hitting the Debug button. And let's try this on the Sample Project. Go ahead and navigate to Level 1 and trial our command. Perfect, so it looks like it's found 17 windows. The FilteredElementCollector is a very powerful tool when working with the Revit API. Throughout the course we'll use this a lot, so you'll become very comfortable with the different ways to filter and collect elements.