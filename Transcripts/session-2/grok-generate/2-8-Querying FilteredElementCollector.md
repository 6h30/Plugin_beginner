kịch bản video hướng dẫn từng bước — trình bày dạng video tutorial có thoại, từng bước rõ ràng, kết hợp phần hình ảnh minh họa , với nội dung sau: 
2-8-
Querying FilteredElementCollector
- [Instructor] Before we continue learning how to create elements, I'd like to take another look at the filtered element collector to learn how to make them more concise through LINQ extensions and lambda expressions. If you have not used LINQ, or Language-Integrated Query before, it is simply a feature of C sharp that allows us to query different data sources and filter the results. This is done using the from, where, and select query operators. For example, from x in data source where x equals some function, select x. So it allows us to filter through data sources using different functions. While we won't be creating LINQ queries in this video, we will be using LINQ extension methods. Extension methods are methods added to an existing object type. LINQ extension methods allows us to add query functionality to existing C sharp IEnumerable types such as a list or the filtered element collector. Extensions include many different methods, such as first to get the first item in a list, select to select items from a list based on a function, or cast, which allows us to cast every item on a list to a specific type, so they can help us further sort through and retrieve just the elements we want from a filtered element collector. Keep in mind though that the quick and slow filters that we have been applying are their own filters, and we should attempt to use them as much as we can before applying LINQ methods as the native filters will be faster. Combining extension methods with lambda expressions gives us even more functionality to filtered collectors. Lambda expressions are anonymous functions, that is a method with no name, and can be written as an inline statement. For example, inside of a select extension method. To write a lambda expression, we need to use the equals angle bracket operator. On the left of this, we can insert a variable which will be the single parameter for our function, and on the right, we insert our function call. For example, x equal to two. So this would check every item in a list if it were equal to two, and if so, return true or false. This could be applied to an IEnumerable type and it would return an IEnumerable list of the results. So let's jump into Visual Studio and try using LINQ extensions and lambda expressions to simplify a filtered element collector. I've currently got the Visual Studio project file open from where we left off in the last video. Here we used a filtered element collector to collect all the family symbols in a project file and find a specific instance. Let's use LINQ extension methods to simplify this. Instead of collecting all the elements and then looping through them, let's add this loop directly into our collector. To do this, first remove the two elements method and next, let's put the where element is element type on the next line, as we'll be applying a few different methods. To start, let's cast all the elements to a specific type so we can then upwrite on them. To do this, let's add the cast method with the type family symbol. Next, let's use the first method so we can apply a function to each family symbol in the list. To the condition, we can use a lambda expression within the parentheses. This condition will simply perform the same function as our four H loop. So to replicate that, let's start with a variable, say x. This will be applied to every element in our list of elements, followed by the lambda operator, and then the action to apply to each element. So let's copy the check we did on line 33 in the if statement, and replace ele with x. As we're retrieving the first element, that is one element, we don't really need to retrieve it as a list, so let's replace our list with family symbol and rename symbols to symbol. Then we can remove the four H loop that we created in the last video. Great, so instead of collecting all elements in a list and looping through each one, we're utilizing LINQ extensions and lambda expressions to perform the loop directly in our collector. Let's go ahead and hit debug to see if that works and open up the Revit exercise file associated with this video. Let's go ahead and try our command again, place family. Perfect, there's our family. LINQ extensions and lambda expressions are very useful to condense our code and make it a little bit more readable. For the rest of the course, we will try different ways of applying these to our filtered element collectors.