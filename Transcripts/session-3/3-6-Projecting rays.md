kịch bản video hướng dẫn từng bước — trình bày dạng video tutorial có thoại, từng bước rõ ràng, kết hợp phần hình ảnh minh họa , với nội dung sau: 
3-6-
Projecting rays
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] Intersection filters are great for checking how two elements clash, but what if we want to check how elements relate that don't touch. To do that we need to project rays, which is the act of sending a vector from a location to see what it hits. It's a way for us to find elements in 3D. To do that, we need to use a class known as a reference intersector. This is used to construct an object that can be used to project a ray and find what it intersects. There are several different constructors that allow us to search for specific elements, all the firsts that it hits. Let's try this one. This will return the first element it intersects based on the filter we provide, such as a category filter. It also needs a target type which is an enumeration of the geometry type we plan to hit, and a view to check it in. Once we've created an object, we can get the intersections of the ray by calling the find, or find nearest methods from the reference intersector object. Both of these take an XYZ origin point, and XYZ vector for the direction of the ray, and it returns a reference with context object. This object can be used to get the reference to the geometry that is being hit. We can then extract the point where the intersection occurs. So let's use this class to check the intersection from the base of a column to the roof above it to get the distance between the two. I currently have the Visual Studio exercise file open for this video. In here I've created a class called ProjectRay, and it's an IExternalCommand, it allows the user to select an object from which the element is retrieved, and then from that element I've retrieved the location point and from that location point I've extracted the XYZ. We can use this as the origin of our ray. By now, you probably realize that this command requires a point-based family to be selected, or it will fail. That's okay though, as we're going to try it on a column. So let's continue on from here. We have an origin point, so let's create our direction. As we'll be projecting straight up from the column base, we just need a vector in the zed axes. To create this, let's create an XYZ variable named rayd, and we'll assign to this a new XYZ using one for the zed parameter. Great, so now we can start building our reference intersector object. First we're going to need a filter to apply to it. Let's filter for roofs as that's what we'll be looking for. So let's create an element category filter named filter, which will be a new element category filter, filtering for the built-in category OST Roofs. Next, let's create the reference intersector using the variable refI. And we'll assign to this a new reference intersector using our new filter for the first parameter, for the fine reference target enumeration, let's select Face, as it will be the underside of the roof, and finally, we need a 3D view. This doesn't affect on what the ray hits, that is if elements are hidden in the view, they won't be included. To get a 3D view, let's cast the view we run the command in to a view 3D object. To do this, add View3D in parentheses, followed by doc.ActiveView. This will retrieve the active view in the document, and then cast it to a View 3D object. Once we have our reference intersector object, we can use it to find elements. So let's use the find nearest method to get the first element that it hits. To do this, create a ReferenceWithContext variable, which we'll name refC. Then assign to this a call to the find nearest method from the reference intersector. This requires the origin of the ray, and the direction that it's shooting. So let's use p1 for our origin, and then rayd for our direction. Now that we have a reference with context object, we can use it to extract data about the reference that it's hit. First we need a reference variable. Let's call that reference with a lowercase R. And then we can get the reference object by calling the getreference method from the reference with context object. So refC.GetReference. Using this reference we can then get the location that the ray hit by accessing the global point property. Let's do that by creating a new XYZ object called intPoint, and assign to that reference.GlobalPoint, perfect. So we now have the intersection point from the ray we projected. Let's check the distance between that and the base point. We can do that by accessing the distance to method from one of the points. This will then let us measure the distance from one point to another. So let's create a double variable named dist, and we'll assign to this a call to the DistanceTo method from the p1 object, and the source will be the intersection point, so intPoint. Then let's display that distance back to the user. To do that, let's use a trusty TaskDialog object calling the Show method, and we'll call it Ray, and for the message, let's use the Format method from the string class which will display the message, Distance to Roof, and then add in our argument. The parameter for this will be the variable dist. This will display as fate as you know. So if you wanted to display this as another unit, you would have to convert it first, using the unit utils class. I've already gone ahead, and added this command into the manifest file. So let's give it a try by hitting the debug button. And opening up the Revit exercise file for this video, then trying our new command, which is called ProjectRay. Then selecting the column, awesome. So it's showing us that the distance from the point of the column to where it intersects the roof is 15.7 feet. The reference intersector is very useful for finding how elements relate in the document. If you want to take this a little further, try playing with the find method as this will find more intersections as the ray bounces around the room.